diff --git a/Makefile b/Makefile
index 82442f4..9a3ac61 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,5 @@
 CARGO_FLAGS += --release
+CARGO_FLAGS += -j 1
 # CARGO_FLAGS += --verbose
 
 zoc: assets
diff --git a/src/core/src/ai.rs b/src/core/src/ai.rs
index 8624e70..4203687 100644
--- a/src/core/src/ai.rs
+++ b/src/core/src/ai.rs
@@ -47,7 +47,7 @@ impl Ai {
             }
             for i in 0 .. 6 {
                 let dir = Dir::from_int(i);
-                let destination = Dir::get_neighbour_pos(&enemy.pos.map_pos, &dir);
+                let destination = Dir::get_neighbour_pos(&enemy.pos.get_map_pos(), &dir);
                 if !self.state.map().is_inboard(&destination) {
                     continue;
                 }
@@ -78,7 +78,9 @@ impl Ai {
             }
             let attacker_type = db.unit_type(&unit.type_id);
             let weapon_type = db.weapon_type(&attacker_type.weapon_type_id);
-            if distance(&unit.pos.map_pos, &target.pos.map_pos) <= weapon_type.max_distance {
+            // гм, гм, это надо переписать
+            // для длинной позиции нельзят ак считать!
+            if distance(&unit.pos.get_map_pos(), &target.pos.get_map_pos()) <= weapon_type.max_distance {
                 return true;
             }
         }
diff --git a/src/core/src/fow.rs b/src/core/src/fow.rs
index d2b545e..d5a7e12 100644
--- a/src/core/src/fow.rs
+++ b/src/core/src/fow.rs
@@ -28,7 +28,7 @@ pub fn fov_unit(
     fow: &mut Map<TileVisibility>,
     unit: &Unit,
 ) {
-    fov_unit_in_pos(db, terrain, fow, unit, &unit.pos.map_pos);
+    fov_unit_in_pos(db, terrain, fow, unit, &unit.pos.get_map_pos());
 }
 
 pub fn fov_unit_in_pos(
@@ -118,7 +118,7 @@ impl Fow {
             }
         }
         let unit_type = db.unit_type(&unit.type_id);
-        self.check_terrain_visibility(unit_type, &pos.map_pos)
+        self.check_terrain_visibility(unit_type, &pos.get_map_pos())
     }
 
     fn clear(&mut self) {
@@ -147,7 +147,7 @@ impl Fow {
                 let unit = state.unit(unit_id);
                 if unit.player_id == self.player_id {
                     fov_unit_in_pos(
-                        db, state.map(), &mut self.map, unit, &to.map_pos);
+                        db, state.map(), &mut self.map, unit, &to.get_map_pos());
                 }
             },
             &CoreEvent::EndTurn{ref new_id, ..} => {
@@ -176,7 +176,7 @@ impl Fow {
             &CoreEvent::UnloadUnit{ref unit_info, ..} => {
                 if self.player_id == unit_info.player_id {
                     let unit = state.unit(&unit_info.unit_id);
-                    let pos = &unit_info.pos.map_pos;
+                    let pos = &unit_info.pos.get_map_pos();
                     fov_unit_in_pos(db, state.map(), &mut self.map, unit, pos);
                 }
             },
diff --git a/src/core/src/game_state.rs b/src/core/src/game_state.rs
index 63ad548..6540657 100644
--- a/src/core/src/game_state.rs
+++ b/src/core/src/game_state.rs
@@ -18,7 +18,7 @@ pub trait GameState {
     fn units_at(&self, pos: &MapPos) -> Vec<&Unit> {
         let mut units = Vec::new();
         for (_, unit) in self.units() {
-            if unit.pos.map_pos == *pos {
+            if unit.pos.cmp_with_map_pos(pos) {
                 units.push(unit);
             }
         }
@@ -28,7 +28,7 @@ pub trait GameState {
     fn objects_at(&self, pos: &MapPos) -> Vec<&Object> {
         let mut objects = Vec::new();
         for (_, object) in self.objects() {
-            if object.pos.map_pos == *pos {
+            if object.pos.cmp_with_map_pos(pos) {
                 objects.push(object);
             }
         }
diff --git a/src/core/src/internal_state.rs b/src/core/src/internal_state.rs
index c6cde49..9e9ad74 100644
--- a/src/core/src/internal_state.rs
+++ b/src/core/src/internal_state.rs
@@ -16,7 +16,7 @@ use ::{
     UnitId,
     MapPos,
     ExactPos,
-    SlotId,
+    // SlotId,
     Object,
     ObjectId,
     ObjectClass,
@@ -64,10 +64,7 @@ impl InternalState {
         *self.map.tile_mut(pos) = Terrain::City;
         let object = Object {
             class: ObjectClass::Building,
-            pos: ExactPos {
-                map_pos: pos.clone(),
-                slot_id: SlotId::WholeTile,
-            },
+            pos: ExactPos::WholeTile{map_pos: pos.clone()},
         };
         self.add_object(object);
     }
@@ -76,7 +73,7 @@ impl InternalState {
         *self.map.tile_mut(pos) = Terrain::City;
         for _ in 0 .. count {
             let slot_id = get_free_slot_for_building(self, pos).unwrap();
-            let obj_pos = ExactPos{map_pos: pos.clone(), slot_id: slot_id};
+            let obj_pos = ExactPos::Slot{map_pos: pos.clone(), slot_id: slot_id};
             let object = Object {
                 class: ObjectClass::Building,
                 pos: obj_pos,
diff --git a/src/core/src/lib.rs b/src/core/src/lib.rs
index f44969d..b02e888 100644
--- a/src/core/src/lib.rs
+++ b/src/core/src/lib.rs
@@ -36,6 +36,7 @@ use db::{Db};
 use ai::{Ai};
 use fow::{Fow};
 use fov::{fov};
+use dir::{Dir};
 
 #[derive(Clone)]
 pub struct MovePoints{pub n: ZInt}
@@ -58,25 +59,58 @@ impl fmt::Display for MapPos {
     }
 }
 
+// #[derive(PartialEq, Clone, Debug)]
+// pub enum SlotId {
+//     Id(u8),
+//     WholeTile,
+//     // Air, // TODO: implement air units
+// }
+
+// #[derive(PartialEq, Clone, Debug)]
+// pub struct ExactPos {
+//     pub map_pos: MapPos,
+//     pub slot_id: SlotId,
+// }
+
+#[derive(PartialOrd, Ord, PartialEq, Eq, Hash, Clone, Debug)]
+pub struct SlotId{pub id: u8}
+
 #[derive(PartialEq, Clone, Debug)]
-pub enum SlotId {
-    Id(u8),
-    WholeTile,
-    // Air, // TODO: implement air units
+pub enum ExactPos {
+    Slot{map_pos: MapPos, slot_id: SlotId},
+    WholeTile{map_pos: MapPos},
+    TwoTiles{map_pos: MapPos, dir: Dir},
+    // ThreeTiles{map_pos: MapPos, dir: Dir}, // TODO
+    // Air, // TODO
 }
 
-#[derive(PartialEq, Clone, Debug)]
-pub struct ExactPos {
-    pub map_pos: MapPos,
-    pub slot_id: SlotId,
+impl ExactPos {
+    // довести до ума или вообще выкинуть.
+    // это же можно доелать другой функцией. оно иеет смысл вообще?
+    pub fn cmp_with_map_pos(&self, _: &MapPos) -> bool {
+        // TODO
+        true
+    }
+
+    // яяя не уверен, что этот метод имеет смысл
+    // что он осмысленное для дороги вернет?  у нее ж де клетки!
+    pub fn get_map_pos(&self) -> &MapPos {
+        match self {
+            &ExactPos::Slot{ref map_pos, ..} => map_pos,
+            &ExactPos::WholeTile{ref map_pos} => map_pos,
+            &ExactPos::TwoTiles{ref map_pos, ..} => map_pos,
+        }
+    }
 }
 
 impl AsRef<MapPos> for ExactPos {
     fn as_ref(&self) -> &MapPos {
-        &self.map_pos
+        // пока закостыли, но это тоже надо будет убрать к черту!
+        self.get_map_pos()
     }
 }
 
+// надо булет убрать
 impl AsRef<MapPos> for MapPos {
     fn as_ref(&self) -> &MapPos {
         self
@@ -424,7 +458,7 @@ fn check_attack<S: GameState>(
         return Err(CommandError::TooClose);
     }
     if !weapon_type.is_inderect {
-        if !los(state.map(), attacker_type, &attacker.pos.map_pos, &defender.pos.map_pos) {
+        if !los(state.map(), attacker_type, &attacker.pos.get_map_pos(), &defender.pos.get_map_pos()) {
             return Err(CommandError::NoLos);
         }
     }
@@ -623,93 +657,95 @@ pub fn get_free_slot_for_building<S: GameState>(
     let objects_at = state.objects_at(pos);
     let mut slots = [false, false, false];
     for object in &objects_at {
-        if let SlotId::Id(slot_id) = object.pos.slot_id {
-            slots[slot_id as usize] = true;
-        } else {
-            return None;
+        match &object.pos {
+            &ExactPos::Slot{ref slot_id, ..} => {
+                slots[slot_id.id as usize] = true;
+            },
+            _ => return None,
         }
     }
     for i in 0..MAX_GROUND_SLOTS_COUNT {
         if !slots[i] {
-            return Some(SlotId::Id(i as u8));
+            return Some(SlotId{id: i as u8});
         }
     }
     None
 }
 
+// гм, возможно функция устарела
 pub fn get_free_exact_pos<S: GameState>(
     db: &Db,
     state: &S,
     type_id: &UnitTypeId,
     pos: &MapPos,
 ) -> Option<ExactPos> {
-    let slot_id = match get_free_slot_id(db, state, type_id, pos) {
-        Some(id) => id,
-        None => return None,
-    };
-    Some(ExactPos{map_pos: pos.clone(), slot_id: slot_id})
-}
+    // let slot_id = match get_free_slot_id(db, state, type_id, pos) {
+    //     Some(id) => id,
+    //     None => return None,
+    // };
 
-pub fn get_free_slot_id<S: GameState>(
-    db: &Db,
-    state: &S,
-    type_id: &UnitTypeId,
-    pos: &MapPos,
-) -> Option<SlotId> {
     let objects_at = state.objects_at(pos);
     let units_at = state.units_at(pos);
     let unit_type = db.unit_type(type_id);
     if unit_type.is_big {
         if units_at.is_empty() && objects_at.is_empty() {
-            return Some(SlotId::WholeTile);
+            return Some(ExactPos::WholeTile{map_pos: pos.clone()});
         } else {
             return None;
         }
     }
     let mut slots = [false, false, false];
     for unit in &units_at {
-        match unit.pos.slot_id {
-            SlotId::Id(slot_id) => slots[slot_id as usize] = true,
-            SlotId::WholeTile => return None,
+        match &unit.pos {
+            &ExactPos::Slot{ref slot_id, ..} => {
+                slots[slot_id.id as usize] = true;
+            },
+            _ => return None,
         }
     }
     if unit_type.class == UnitClass::Vehicle {
         for object in &objects_at {
-            match object.pos.slot_id {
-                SlotId::Id(slot_id) => {
-                    slots[slot_id as usize] = true;
+            match &object.pos {
+                &ExactPos::Slot{ref slot_id, ..} => {
+                    slots[slot_id.id as usize] = true;
                 },
-                SlotId::WholeTile => return None,
+                _ => return None,
             }
         }
     }
     for i in 0..MAX_GROUND_SLOTS_COUNT {
         if !slots[i] {
-            return Some(SlotId::Id(i as u8));
+            return Some(ExactPos::Slot {
+                map_pos: pos.clone(),
+                slot_id: SlotId{id: i as u8},
+            });
         }
     }
     None
+
+    // Some(ExactPos::Slot{map_pos: pos.clone(), slot_id: slot_id})
 }
 
-// TODO: join logic with get_free_slot_id
+// TODO: join logic with get_free_slot_id - устарело
 pub fn is_exact_pos_free<S: GameState>(
     db: &Db,
     state: &S,
     type_id: &UnitTypeId,
     pos: &ExactPos,
 ) -> bool {
-    let units_at = state.units_at(&pos.map_pos);
+    let units_at = state.units_at(&pos.get_map_pos());
     if db.unit_type(type_id).is_big {
         return units_at.is_empty();
     }
     for unit in &units_at {
-        match &unit.pos.slot_id {
-            slot_id @ &SlotId::Id(_) => {
-                if *slot_id == pos.slot_id {
+        match &unit.pos {
+            &ExactPos::Slot{..} => {
+                if unit.pos == *pos {
                     return false;
                 }
-            }
-            &SlotId::WholeTile => return false,
+            },
+            &ExactPos::WholeTile{..} => return false,
+            &ExactPos::TwoTiles{..} => return false,
         }
     }
     true
diff --git a/src/core/src/pathfinder.rs b/src/core/src/pathfinder.rs
index d76025a..1d9dc85 100644
--- a/src/core/src/pathfinder.rs
+++ b/src/core/src/pathfinder.rs
@@ -8,19 +8,17 @@ use map::{Map, Terrain};
 use partial_state::{PartialState};
 use game_state::{GameState};
 use dir::{Dir, dirs};
-use ::{MovePoints, MapPos, ExactPos, SlotId, get_free_exact_pos};
+use ::{MovePoints, MapPos, ExactPos, /*SlotId,*/ get_free_exact_pos};
 
 #[derive(Clone)]
 pub struct Tile {
     cost: MovePoints,
-    parent: Option<Dir>,
-    slot_id: SlotId,
+    parent: Option<ExactPos>,
 }
 
 impl Tile {
-    pub fn parent(&self) -> &Option<Dir> { &self.parent }
+    pub fn parent(&self) -> &Option<ExactPos> { &self.parent }
     pub fn cost(&self) -> &MovePoints { &self.cost }
-    pub fn slot_id(&self) -> &SlotId { &self.slot_id }
 }
 
 impl Default for Tile {
@@ -28,7 +26,6 @@ impl Default for Tile {
         Tile {
             cost: MovePoints{n: 0},
             parent: None,
-            slot_id: SlotId::WholeTile,
         }
     }
 }
@@ -81,7 +78,7 @@ pub fn obstacles_count<S: GameState>(
 pub fn tile_cost<S: GameState>(db: &Db, state: &S, unit: &Unit, pos: &ExactPos)
     -> MovePoints
 {
-    let obstacles_count = obstacles_count(state, &pos.map_pos);
+    let obstacles_count = obstacles_count(state, pos.get_map_pos());
     let unit_type = db.unit_type(&unit.type_id);
     let tile = state.map().tile(&pos);
     let n = match unit_type.class {
@@ -130,9 +127,7 @@ impl Pathfinder {
         let new_cost = MovePoints{n: old_cost.n + tile_cost.n};
         if tile.cost.n > new_cost.n {
             tile.cost = new_cost;
-            tile.parent = Some(Dir::get_dir_from_to(
-                &neighbour_pos.map_pos, &original_pos.map_pos));
-            tile.slot_id = neighbour_pos.slot_id.clone();
+            tile.parent = Some(neighbour_pos.clone());
             self.queue.push(neighbour_pos.clone());
         }
     }
@@ -142,7 +137,6 @@ impl Pathfinder {
             let tile = self.map.tile_mut(&pos);
             tile.cost = max_cost();
             tile.parent = None;
-            tile.slot_id = SlotId::WholeTile;
         }
     }
 
@@ -155,7 +149,7 @@ impl Pathfinder {
     ) {
         assert!(self.map.is_inboard(&pos));
         for dir in dirs() {
-            let neighbour_pos = Dir::get_neighbour_pos(&pos.map_pos, &dir);
+            let neighbour_pos = Dir::get_neighbour_pos(pos.get_map_pos(), &dir);
             if self.map.is_inboard(&neighbour_pos) {
                 let exact_neighbour_pos = match get_free_exact_pos(
                     db, state, &unit.type_id, &neighbour_pos
@@ -173,7 +167,6 @@ impl Pathfinder {
         let start_tile = self.map.tile_mut(&start_pos);
         start_tile.cost = MovePoints{n: 0};
         start_tile.parent = None;
-        start_tile.slot_id = start_pos.slot_id.clone();
         self.queue.push(start_pos);
     }
 
@@ -202,15 +195,10 @@ impl Pathfinder {
         while self.map.tile(&pos).cost.n != 0 {
             assert!(self.map.is_inboard(&pos));
             path.push(pos.clone());
-            let parent_dir = match self.map.tile(&pos).parent() {
-                &Some(ref dir) => dir,
+            pos = match self.map.tile(&pos).parent() {
+                &Some(ref parent) => parent.clone(),
                 &None => return None,
             };
-            let neighbour_map_pos = Dir::get_neighbour_pos(&pos.map_pos, parent_dir);
-            pos = ExactPos {
-                map_pos: neighbour_map_pos.clone(),
-                slot_id: self.map.tile(&neighbour_map_pos).slot_id.clone(),
-            };
         }
         path.reverse();
         if path.is_empty() {
diff --git a/src/visualizer/src/geom.rs b/src/visualizer/src/geom.rs
index aba790d..cb0383e 100644
--- a/src/visualizer/src/geom.rs
+++ b/src/visualizer/src/geom.rs
@@ -17,13 +17,14 @@ pub fn map_pos_to_world_pos(p: &MapPos) -> WorldPos {
 }
 
 pub fn exact_pos_to_world_pos(p: &ExactPos) -> WorldPos {
-    let v = geom::map_pos_to_world_pos(&p.map_pos).extend(0.0);
-    match p.slot_id {
-        SlotId::WholeTile => {
-            WorldPos{v: v + index_to_circle_vertex_rnd(3, 0, &p.map_pos).v.mul_s(0.2)}
+    let v = geom::map_pos_to_world_pos(&p.get_map_pos()).extend(0.0);
+    match p {
+        &ExactPos::WholeTile{..} => {
+            WorldPos{v: v + index_to_circle_vertex_rnd(3, 0, &p.get_map_pos()).v.mul_s(0.2)}
         }
-        SlotId::Id(n) => {
-            WorldPos{v: v + index_to_circle_vertex_rnd(3, n as ZInt, &p.map_pos).v.mul_s(0.5)}
+        &ExactPos::Slot{ref slot_id, ..} => {
+            let n = slot_id.id as ZInt;
+            WorldPos{v: v + index_to_circle_vertex_rnd(3, n, &p.get_map_pos()).v.mul_s(0.5)}
         }
     }
 }
diff --git a/src/visualizer/src/tactical_screen.rs b/src/visualizer/src/tactical_screen.rs
index d74ad43..ab70d3d 100644
--- a/src/visualizer/src/tactical_screen.rs
+++ b/src/visualizer/src/tactical_screen.rs
@@ -140,16 +140,11 @@ fn build_walkable_mesh(
         if pf.get_map().tile(&tile_pos).cost().n > move_points.n {
             continue;
         }
-        if let &Some(ref parent_dir) = pf.get_map().tile(&tile_pos).parent() {
-            let tile_pos_to = Dir::get_neighbour_pos(&tile_pos, parent_dir);
+        if let Some(exact_pos_to) = pf.get_map().tile(&tile_pos).parent().clone() {
             let exact_pos = ExactPos {
                 map_pos: tile_pos.clone(),
                 slot_id: pf.get_map().tile(&tile_pos).slot_id().clone(),
             };
-            let exact_pos_to = ExactPos {
-                map_pos: tile_pos_to.clone(),
-                slot_id: pf.get_map().tile(&tile_pos_to).slot_id().clone(),
-            };
             let world_pos_from = geom::exact_pos_to_world_pos(&exact_pos);
             let world_pos_to = geom::exact_pos_to_world_pos(&exact_pos_to);
             vertex_data.push(VertexCoord{v: geom::lift(world_pos_from.v)});
