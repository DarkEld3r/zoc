TODO: переведи, когда закончишь

Частичные повреждения? Эффекты?

Хрен знает, как затолкат ьсистему эффектов в текущую архитектуру.
Я могу в каждое событие атаки добавить вектор эффектов, но это решение
далеко не универсальное:

* я все еще не могу одной атакой повредить несколько целей (большой взрыв)

* хотелось бы иметь возможность накладывать эффекты при любом событии
  Допустим, при движении по сложной местности техника может застрять на ход.


Можно было бы обойти все это, просто добавив событие CoreEvent::Effect и добавляя его
в симуляции в нужный момент, НО

- теряется семантическая связсь между событиями

  - как визуализатору отличить простое передвижение врага от бегства после атаки?
  - как визуализировать атаку, которая не уничтожила врага, но наложила эффект?
    ввести несколько результатов атаки (убил,промазал, эффект), последний из которых
    будет как-то активировать сложную логику "посмотри, какое событие следующее"?

Посему есть мысль преобразовать CoreEvent в

```
enum Event {
    Move(id, from, to},
    Attack(id, id},
    ...,
}

enum Time {
    Instant,
    Turns(u8),
    Forever,
}

struct TimedEffect {
    effect: Effect,
    time: Time,
}

enum Effect {
    Killed(u8),
    Suppressed,
    MoraleDown,
    ...,
}

struct CoreEvent {
    event: Event,
    effects: HashMap<UnitId, Vec<TimedEffect>>,
}
```

Агент - объект, который инициировал событие.
У события может и не быть агента (конец хода),
а может быть разу несколько агентов (теоретически).

Цель - объект, который является невольным участником события.
Цель может и одобрять событие (транспортер одобрит погрущку в него пехоты),
так и не одобрять (при обстреле вражеского отряда).

При применении эффекта в метод будет передано само событие, что бы был контекст.

Вопрос: где провести грань - что должно быть полем события, а что отдельным эффектом?
Первое что мне пока приходит в голову - к чему относится информация? К цели или к агенту?
Если к агенту, то пускай будет полем события, если к цели - эффект.
Вроде, разумно.

TODO: приведи примеры

Таким образом, визуализатор из события и эффектов сможет создать целостную,
логически связанную картину произошедшего.

------

// `State::apply_effect` - параметр event?

TODO: И вот тут возникает вопрос - что делать с событием?
если я соранил TimedEffect, то самого события у меня уже на руках нет.

Т.е. выходит что мгновенно применяемые эффекты могут полагаться на
данные из самого события, а вот отложенные эффекты должно быть
независимы ни от чего. Ну отлично.

С другой стороны - а где мне само событие нужно?
только в визуализаторе, потому что на уровне логики событие
отдельно применится к агенту.

------

Есть сложность с визуализатором - я не могу просто визуализировать событие атаки,
потому что не знаю, например, куда должен лететь снаряд.

Какой выход я могу найти? Переместить всю эту логику в визуализатор эффекта,
потому что у него есть доступ и к самому событию.
Но к какому из эффектов? Это у меня сейчас временный общий эффект от атаки,
а так их много должно быть разных сразу.

С другой стороны у визуализатора события может быть доступ и ко всем эффектам -
можно на основе эффектов и типа атаки чет делать. Хз.

Или в AttackInfo можно положить `target_pos: ExactPos`?
Этого хватит для начальной визуализации, а там разберемся.

-------

Вообще, это странный момент: как визуализировать событие атаки,
если оно из засады и я вообще не могу рисовать снаряд?

Может, надо как-то обозначать район, из которого "прилетело"?
В духе "случайно сдвинутый круг из 7 клеток,
из одной из которых и стреляли".

-------

Для нормального показа эффектов мне таки нужно разбить монолитные
визуализаторы осбытий на микродействия с узлами (найти номер задачи).

Как их реализовать?

Для начала, пусть в TacticalScreen поле
`event_visualizer: Option<Box<event_visualizer::EventVisualizer>>`
станет
`event_visualizers: Vec<Box<event_visualizer::EventVisualizer>>`.

Причем все события из ядра тоже должны получаться вектором,
а не по одной функции.

Т.е.
`fn get_event(&mut self) -> Option<CoreEvent>`
станет
`fn get_events(&mut self) -> Vec<CoreEvent>`.

-------

// TODO: вот это поле тоже надо обработать и втолкать в `event_visualizers`,
// ведь все это дело после показа тоже применять придется.
// Только учти что у эффектов отдельные визуализаторы.
event: Option<CoreEvent>,


fn logic(&mut self, context: &mut Context) {
    // TODO: переделать на вектор, эта логика совсем устарела.
    //
    // Что тут надо делать? Пробовать вытянуть из ядра события,
    // добавлять их визуализаторы в self.event_visualizers.
    // И, если event_visualizers до этого был пустым, начинать играть?
    //
    // Если текущий визуализатор закончился, то применить его событие-эффект
    // И убрать из вектора.
    //
    // Кстати, хороший вопрос - как мне применять всю эту хрень?
    // Если у меня используются для событий и эффектов одни EventVisualizer
    //
    // NOTE: если я буду много удалять из начала вектора, то, наверное
    // лучше взять тут VecDeque?
    //
    /*
    if self.event_visualizer.is_none() {
        if let Some(event) = self.core.get_event() {
            self.start_event_visualization(context, event);
        }
    } else if self.is_event_visualization_finished() {
        self.end_event_visualization(context);
    }
    */
}

------

I should replace all the MapText machinery with simple
Actions somehow.

------

Ok, I have a problem: when unit is created its NodeId is allocated
dynamically, but I need to know NodeId to create chain of actions like
`Create->Move` :-(

I still have an UnitId and can pass it to every action, but
this way my actions will be tied too closely to units
and I want Action to be useful for all SceneNodes.
